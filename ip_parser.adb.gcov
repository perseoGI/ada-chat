        -:    0:Source:/mnt/c/Users/reiva/source/ada-chat/src/utils/ip_parser.adb
        -:    1:with Ada.Text_IO,
        -:    2:    Ada.Containers.Indefinite_Vectors,
        -:    3:    Ada.Strings.Fixed,
        -:    4:	Ada.Strings.Maps,
        -:    5:    Ada.Characters.Handling,
        -:    6:    Ada.Strings.Unbounded,
        -:    7:	Ada.Strings.Unbounded.Text_IO;
        -:    8:
        -:    9:use Ada.Text_IO,
        -:   10:    Ada.Containers,
        -:   11:    Ada.Strings,
        -:   12:    Ada.Strings.Fixed,
        -:   13:	Ada.Strings.Maps,
        -:   14:    Ada.Characters.Handling,
        -:   15:    Ada.Strings.Unbounded,
        -:   16:	Ada.Strings.Unbounded.Text_IO;
        -:   17:
        -:   18:package body IP_Parser is
        -:   19:
        -:   20:	package String_Vectors is new Indefinite_Vectors (Positive, String);
        -:   21:	use String_Vectors;
        -:   22:
        1:   23:	function String_Tokenize (Str: String; Delimiter: String) return Vector is
        1:   24:		Start  : Positive := Str'First;
        1:   25:		Finish : Natural  := 0;
        1:   26:		Output : Vector   := Empty_Vector;
        -:   27:	begin
        5:   28:		while Start <= Str'Last loop
        -:   29:			-- From is in, First and Last are out parameters
        4:   30:			Find_Token (Source => Str, Set => To_Set (Delimiter), From => Start,
        -:   31:						Test => Outside, First => Start, Last => Finish);
        4:   32:			exit when Start > Finish;
        4:   33:			Output.Append (Str (Start .. Finish));
        4:   34:			Start := Finish + 1;
        4:   35:		end loop;
        2:   36:		return Output;
        1:   37:	end String_Tokenize;
        -:   38:
        -:   39:
        1:   40:	function Is_String_IpV4(Str: String) return Boolean is
        1:   41:		Tokens: Vector := Empty_Vector;
        -:   42:		Frac: Integer;
        -:   43:	begin
        -:   44:
        3:   45:		Tokens := String_Tokenize(Str => Str, Delimiter => ".");
        -:   46:
        1:   47:		if Tokens.Length /= 4 then
    #####:   48:			return False;
        -:   49:		end if;
        -:   50:
       10:   51:		for Token of Tokens loop
        4:   52:			if Token'Length > 0 then
       15:   53:				for T of Token loop
       11:   54:					if not Is_Digit(T) then
    #####:   55:						return False;
        -:   56:					end if;
        -:   57:				end loop;
        4:   58:				Frac := Integer'Value(Token);
        4:   59:				if Frac > 255 then
    #####:   60:					return False;
        -:   61:				end if;
        -:   62:			end if;
        -:   63:
        -:   64:		end loop;
        -:   65:
        1:   66:		return True;
        1:   67:	end Is_String_IpV4;
        -:   68:
        -:   69:	type Test_Case is record
        -:   70:		content: unbounded_string;
        -:   71:		valid: Boolean;
        -:   72:	end record;
        -:   73:
        -:   74:	type Test_Case_Vector is array (Positive range <>) of Test_Case;
        -:   75:
    #####:   76:	procedure Is_String_IpV4_Test is
    #####:   77:		Test_Values: Test_Case_Vector := (
    #####:   78:				(To_Unbounded_String("200.32.4"), False),
    #####:   79:				(To_Unbounded_String("12.324.53.3"), False),
    #####:   80:				(To_Unbounded_String("12.324.53.3"), False),
    #####:   81:				(To_Unbounded_String("192.200.23.256"), False),
    #####:   82:				(To_Unbounded_String("-1.23.43.5"), False),
    #####:   83:				(To_Unbounded_String("1.23.+43.5"), False),
    #####:   84:				(To_Unbounded_String("1.23.43.5t"), False),
    #####:   85:				(To_Unbounded_String("1.23.4a3.05"), False),
    #####:   86:				(To_Unbounded_String("asd"), False),
    #####:   87:				(To_Unbounded_String("a.b.d.f.g"), False),
    #####:   88:				(To_Unbounded_String("142.24.52.5"), True),
    #####:   89:				(To_Unbounded_String("192.200.23.23"), True),
    #####:   90:				(To_Unbounded_String("0.0.0.0"), True),
    #####:   91:				(To_Unbounded_String("001.023.043.05"), True)
        -:   92:				) ;
        -:   93:		Result: Boolean;
        -:   94:	begin
    #####:   95:		Put_Line("Running Unit Tests for Is_String_IpV4..." & ASCII.LF);
    #####:   96:		for TestValue of Test_Values loop
    #####:   97:			Result := Is_String_IpV4(To_String(TestValue.content));
    #####:   98:			Ada.Text_IO.Set_Col(4);
    #####:   99:			if TestValue.valid /= Result then
    #####:  100:				Put("[ERROR]  ");
        -:  101:			else
    #####:  102:				Put("[ OK ]   ");
        -:  103:			end if;
    #####:  104:			Ada.Text_IO.Set_Col(14);
    #####:  105:			Put(To_String(TestValue.content));
    #####:  106:			Ada.Text_IO.Set_Col(34);
    #####:  107:			Put_Line(" is " & (if TestValue.valid = True then "valid" else "invalid"));
        -:  108:		end loop;
        -:  109:
    #####:  110:	end Is_String_IpV4_Test;
        -:  111:
        -:  112:end IP_Parser;
